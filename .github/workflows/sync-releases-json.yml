name: Sync GitHub Releases to JSON

on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    strategy:
      matrix:
        type: [stable, prerelease]

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.repository.default_branch }}

      - uses: actions/setup-node@v4

      - name: Update ${{ matrix.type }} releases JSON
        id: update-json
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_REPO: ${{ github.repository }}
          MANUAL_RUN: ${{ github.event_name == 'workflow_dispatch' }}
          RELEASE_TYPE: ${{ matrix.type }}
        run: |
          node <<'EOF'
          const { execSync } = require('child_process');
          const fs = require('fs');

          const isManual = process.env.MANUAL_RUN === 'true';
          const repo = process.env.GH_REPO;
          const type = process.env.RELEASE_TYPE;
          const file = type === 'stable' ? 'releases.json' : 'releases-pre.json';
          const isPrerelease = type === 'prerelease';
          const hasFile = fs.existsSync(file);

          function gh(path, args = '') {
            return JSON.parse(execSync(`gh api ${path} ${args}`, { encoding: 'utf8' }));
          }

          function getAllReleases() {
            const perPage = 100;
            let page = 1, releases = [], fetched;
            do {
              fetched = gh(`/repos/${repo}/releases?per_page=${perPage}&page=${page}`);
              releases.push(...fetched.filter(r =>
                !r.draft && !!r.prerelease === isPrerelease
              ));
              page++;
            } while (fetched.length === perPage);
            return releases;
          }

          function getLatestRelease() {
            try {
              const r = gh(`/repos/${repo}/releases/latest`);
              return (!r.draft && (!!r.prerelease === isPrerelease)) ? [r] : [];
            } catch {
              return [];
            }
          }

          const existing = hasFile ? JSON.parse(fs.readFileSync(file, 'utf8')) : [];
          const existingMap = new Map(existing.map(r => [r.version, r]));
          const releases = isManual || !hasFile ? getAllReleases() : getLatestRelease();

          const map = new Map(existingMap);  // clone
          let addedVersions = [];

          for (const r of releases) {
            const assets = r.assets.map(a => ({
              name: a.name,
              url: a.browser_download_url,
              size: a.size,
              digest: a.digest  // sha256
            }));
            const version = r.tag_name;
            const entry = { version, url: r.html_url, assets };

            const existed = map.has(version);
            if (!existed || JSON.stringify(map.get(version)) !== JSON.stringify(entry)) {
              map.set(version, entry);
              if (!existed) {
                addedVersions.push(version);
              }
            }
          }

          let removed = 0;
          if (isManual || !hasFile) {
            const valid = new Set(releases.map(r => r.tag_name));
            for (const version of [...map.keys()]) {
              if (!valid.has(version)) {
                map.delete(version);
                removed++;
              }
            }
          }

          if (map.size === 0) {
            if (fs.existsSync(file)) {
              fs.writeFileSync(file, '[]\n');
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `skip_commit=false\n`);
            } else {
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `skip_commit=true\n`);
            }
            process.exit(0);
          }

          // sort by version (desc)
          const out = [...map.values()].sort((a, b) =>
            b.version.localeCompare(a.version, undefined, { numeric: true })
          );
          fs.writeFileSync(file, JSON.stringify(out, null, 2) + '\n');

          fs.appendFileSync(process.env.GITHUB_OUTPUT, [
            `initial=${!hasFile}`,
            `added_versions=${addedVersions.join(',')}`,
            `manual=${isManual}`,
            `removed=${removed}`,
            `file=${file}`,
            `skip_commit=false`
          ].join('\n') + '\n');
          EOF

      - name: Commit and push if changed
        if: steps.update-json.outputs.skip_commit != 'true'
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"

          FILE="${{ steps.update-json.outputs.file }}"
          git add "$FILE"

          if ! git diff --cached --quiet; then
            INITIAL="${{ steps.update-json.outputs.initial }}"
            ADDED_VERSIONS="${{ steps.update-json.outputs.added_versions }}"
            MANUAL="${{ steps.update-json.outputs.manual }}"
            REMOVED="${{ steps.update-json.outputs.removed }}"

            IFS=',' read -r -a VERSIONS <<< "$ADDED_VERSIONS"
            ADDED_COUNT="${#VERSIONS[@]}"

            if [ "$INITIAL" = "true" ]; then
              MSG="Initial $FILE"
            elif [ "$ADDED_COUNT" -gt 0 ]; then
              MSG="Update $FILE for version ${VERSIONS[0]}"
            elif [ "$MANUAL" = "true" ] && [ "$REMOVED" -gt 0 ]; then
              MSG="chore: sync $FILE"
            else
              MSG="Update $FILE"
            fi

            git commit -m "$MSG"
            git pull --rebase origin $(git rev-parse --abbrev-ref HEAD)
            git push
          fi
